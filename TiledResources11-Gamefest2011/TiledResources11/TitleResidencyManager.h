//--------------------------------------------------------------------------------------
// TitleResidencyManager.h
//
// The title residency manager is the centerpiece of the title systems for managing
// tiled resources.  It maintains a list of all of the tiled resource tiles that are in
// use, manages streaming data into those tiles and mapping/unmapping tiles through the
// loader and unloader threads, and also processes samples generated by residency passes,
// which add new tiles to the tracking lists.
//
// Note that each title developer will need to implement a similar system to this, 
// according to the specific streaming requirements of each title.
//
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once

#include <windows.h>
#include <d3d11.h>
#include <xnamath.h>

#include <vector>
#include <deque>
#include <hash_map>
#include <stack>
#include <algorithm>

#include "d3d11tiled.h"
#include "ThreadSafeQueue.h"

#define ASSERT(x) assert(x)

typedef UINT ResourceSetID;

// Set this define to 1 to make loader debugging easier (only one instance will be active)
#define LOADER_DEBUG 0

#if LOADER_DEBUG
#define MAX_LOADER_THREAD_COUNT 1
#else
#define MAX_LOADER_THREAD_COUNT 8
#endif

#define MAX_UNLOADER_THREAD_COUNT 1

class TitleResidencyManager;

//--------------------------------------------------------------------------------------
// Name: TrackedTileID
// Desc: The public description of a tile that is being tracked by the title residency
//       manager.  It contains all information required to locate the tile within a
//       resource, load data into that tile, and manage its lifetime within the title
//       residency manager.
//--------------------------------------------------------------------------------------
struct TrackedTileID
{
    // The resource that this tile belongs to:
    ID3D11TiledTexture2D* pResource;

    // The virtual address of this tile (this will always be unique):
    D3D11_TILED_VIRTUAL_ADDRESS VTileID;

    // The physical address of this tile (this may not be unique, or may be NULL):
    D3D11_TILED_PHYSICAL_ADDRESS PTileID;

    // The texture space U address where this tile was first observed:
    FLOAT U;

    // The texture space V address where this tile was first observed:
    FLOAT V;

    // The mip level that this tile inhabits:
    USHORT MipLevel;

    // The array slice index that this tile inhabits:
    USHORT ArraySlice;

    // If PinnedTile is TRUE, the title residency manager will never unmap or delete
    // this tile:
    BOOL PinnedTile;
};

//--------------------------------------------------------------------------------------
// Name: ITileLoader
// Desc: The interface for tile loader classes.  The title residency manager can track
//       one unique tile loader per resource, or it can share a tile loader among several
//       resources.
//--------------------------------------------------------------------------------------
class ITileLoader
{
private:
    friend class TitleResidencyManager;

    // The tile loader holds pointers to one context per thread.
    // The thread count is defined at runtime by the title residency manager.
    VOID* m_pLoaderContexts[MAX_LOADER_THREAD_COUNT];
    VOID* m_pUnloaderContexts[MAX_UNLOADER_THREAD_COUNT];

    // This pointer points to a running variable within the title residency manager:
    volatile BOOL* m_pRunning;

public:
    // A pointer to the single D3D11 tile pool:
    ID3D11TilePool* m_pTilePool;

    ITileLoader()
    {
        // Make sure unused contexts are NULL.
        for( UINT i = 0; i < ARRAYSIZE(m_pLoaderContexts); ++i )
        {
            m_pLoaderContexts[i] = NULL;
        }
        for( UINT i = 0; i < ARRAYSIZE(m_pUnloaderContexts); ++i )
        {
            m_pUnloaderContexts[i] = NULL;
        }
        m_pTilePool = NULL;
        m_pRunning = NULL;
    }

    virtual ~ITileLoader()
    {
    }

    virtual VOID* CreateThreadContext() { return NULL; }
    virtual VOID DestroyThreadContext( VOID* pThreadContext ) {}
    virtual BOOL TileNeedsUniquePhysicalTile( TrackedTileID* pTileID ) { return TRUE; }

    // Pure virtual methods that must be implemented by the subclasses:
    virtual HRESULT LoadAndMapTile( TrackedTileID* pTileID, VOID* pThreadContext ) = NULL;
    virtual HRESULT UnmapTile( TrackedTileID* pTileID, VOID* pThreadContext ) = NULL;

protected:
    virtual VOID CleanupContexts()
    {
        for( UINT i = 0; i < ARRAYSIZE(m_pLoaderContexts); ++i )
        {
            if( m_pLoaderContexts[i] != NULL )
            {
                DestroyThreadContext( m_pLoaderContexts[i] );
                m_pLoaderContexts[i] = NULL;
            }
        }
        for( UINT i = 0; i < ARRAYSIZE(m_pUnloaderContexts); ++i )
        {
            if( m_pUnloaderContexts[i] != NULL )
            {
                DestroyThreadContext( m_pUnloaderContexts[i] );
                m_pUnloaderContexts[i] = NULL;
            }
        }
    }

    BOOL IsRunning() const
    {
        if( m_pRunning )
        {
            return *m_pRunning;
        }
        return TRUE;
    }
};

//--------------------------------------------------------------------------------------
// Name: ITileActivityHandler
// Desc: A simple callback interface that allows external classes to be notified when
//       tiles are loaded or unloaded.
//--------------------------------------------------------------------------------------
class ITileActivityHandler
{
public:
    virtual VOID TileLoaded( const TrackedTileID* pTileID ) = NULL;
    virtual VOID TileUnloaded( const TrackedTileID* pTileID ) = NULL;
};

//--------------------------------------------------------------------------------------
// Name: ResidencyStats
// Desc: A struct that holds statistics related to tile management.  The title residency
//       manager updates statistics in this struct each frame.
//--------------------------------------------------------------------------------------
struct ResidencyStats
{
    BOOL OutOfPhysicalTiles;
    UINT NumTilesTracked;
    UINT NumTilesLoaded;
    UINT NumTilesQueuedForLoad;
    UINT NumTilesUnused;
    UINT LoaderThreadCount;
    UINT UnloaderThreadCount;
};

//--------------------------------------------------------------------------------------
// Name: TitleResidencyManager
// Desc: Manages tile residency and streaming across all of the tiled resources used by
//       the title.
//--------------------------------------------------------------------------------------
class TitleResidencyManager
{
public:
    // Each tracked tile has one of the following states:
    enum TrackedTileState
    {
        // The tile has been seen at least once:
        TPS_Seen,

        // The tile has been seen enough times to be queued for loading:
        TPS_QueuedForLoad,

        // The tile is currently being processed by a tile loader:
        TPS_Loading,

        // The tile is fully loaded and mapped:
        TPS_LoadedAndMapped,

        // The tile is no longer important, and needs to be unmapped:
        TPS_QueuedForUnmap,

        // The tile is currently being unmapped by a tile loader:
        TPS_Unmapping,

        // The tile has been unmapped, and the physical tile can be released or recycled:
        TPS_Unmapped
    };

    //--------------------------------------------------------------------------------------
    // Name: TrackedTile
    // Desc: The internal tracking structure for a tracked tile within the title residency
    //       manager.  In addition to the public information in the TrackedTileID struct,
    //       this enhanced record includes the state of the tile, the associated tile loader,
    //       and statistics related to how often the tile has been seen and how important
    //       the tile is to the rendered scene.
    //--------------------------------------------------------------------------------------
    struct TrackedTile
    {
        // Information that identifies the tile:
        TrackedTileID ID;

        // The state of the tile in the tracking system:
        TrackedTileState State;

        // The tile loader associated with the resource that this tile belongs to:
        ITileLoader* pTileLoader;

        // The number of times that the tile has shown up in residency samples:
        UINT SampleCount;

        // The last frame time this tile was seen in a residency pass:
        UINT LastTimeSeen;

        // A score that represents how close the tile was to the center of the render view last time it was seen:
        UINT ViewPositionScore;

        // A snapshot of the priority score when the tile was queued for loading:
        UINT InsertPriority;

        // The continuously updated priority score as the tile is queued for loading:
        UINT CurrentPriority;
    };
    typedef std::list<TrackedTile*> TrackedTileSortList;

private:
    //--------------------------------------------------------------------------------------
    // Name: SamplingView
    // Desc: The D3D11 resources associated with one residency sample view target, including
    //       render target textures, render target views, and shader resource views.
    //--------------------------------------------------------------------------------------
    struct SamplingView
    {
        UINT RenderFrameIndex;

        ID3D11Texture2D* pRenderTargetTextureUVGradientID;
        ID3D11Texture2D* pStagingTextureUVGradientID;
        ID3D11RenderTargetView* pRenderTargetViewUVGradientID;
        ID3D11ShaderResourceView* pSRViewUVGradientID;

        ID3D11Texture2D* pRenderTargetTextureExtendedUVSlice;
        ID3D11Texture2D* pStagingTextureExtendedUVSlice;
        ID3D11RenderTargetView* pRenderTargetViewExtendedUVSlice;
        ID3D11ShaderResourceView* pSRViewExtendedUVSlice;
    };

    //--------------------------------------------------------------------------------------
    // Name: ResourceSet
    // Desc: A set of tiled resources that share the same UV texture mapping in the scene
    //       content.  This way, one residency sample can be used to infer residency for
    //       several different resources, even if they differ in size and content.
    //--------------------------------------------------------------------------------------
    struct ResourceSet
    {
        ResourceSetID ID;
        ID3D11TiledTexture2D** ppResources;
        ITileLoader** ppTileLoaders;
        UINT ResourceCount;
    };

    //--------------------------------------------------------------------------------------
    // Name: ThreadEntryContext
    // Desc: A structure used to pass initialization information to the loader threads.
    //--------------------------------------------------------------------------------------
    struct ThreadEntryContext
    {
        TitleResidencyManager* pTRM;
        UINT ThreadIndex;
    };

protected:
    UINT m_FrameIndex;
    UINT m_CurrentFrameTime;

    ID3D11DeviceContext* m_pd3dDeviceContext;

    ID3D11TilePool* m_pTilePool;

    // The title residency manager has a overall physical tile limit:
    UINT m_AllocatedTileCount;
    UINT m_MaxPhysicalTiles;

    // D3D11 members for the residency sample rendering:
    D3D11_VIEWPORT m_Viewport;
    ID3D11Texture2D* m_pDepthStencilTexture;
    ID3D11DepthStencilView* m_pDepthStencil;
    ID3D11BlendState* m_pBlendState;
    ID3D11DepthStencilState* m_pDepthStencilState;

    std::vector<SamplingView> m_SamplingViews;
    UINT m_CurrentViewIndex;
    UINT m_NextViewIndex;

    // The list of tracked tiles, indexed by virtual address and also as a sorted list:
    typedef stdext::hash_map<D3D11_TILED_VIRTUAL_ADDRESS, TrackedTile*> TrackedTileMap;
    TrackedTileMap m_TrackedTileMap;
    TrackedTileSortList m_TrackedTileSortList;

    // A stack of uninitialized TrackedTile structs to minimize new/delete on these small structs:
    std::stack<TrackedTile*> m_TrackedTileFreeList;

    // The list of resource sets:
    std::vector<ResourceSet> m_ResourceSets;

    // The list of tile activity handlers that are notified when tiles are loaded and unloaded:
    std::vector<ITileActivityHandler*> m_TileActivityHandlers;

    // The gradient scaling factor is used to encode and decode texture UV gradients captured
    // during the residency sample pass:
    FLOAT m_fGradientScalingFactor;

    // The queue for tiles waiting to be loaded:
    ThreadSafePriorityQueue<TrackedTile*> m_LoadQueue;

    // The queue for tiles waiting to be unmapped:
    ThreadSafeQueue<TrackedTile*> m_UnmapQueue;

    // The queue of physical tiles that have been unmapped and can be recycled:
    ThreadSafeQueue<D3D11_TILED_PHYSICAL_ADDRESS> m_TileRecycleQueue;

    // A flag that indicates that tiles are waiting to be loaded, but there are no
    // free physical tiles:
    BOOL m_NeedPhysicalTilesNow;

    // Loader thread handles:
    HANDLE m_hLoaderThreads[MAX_LOADER_THREAD_COUNT];

    // A signaling event that tells the loader threads that at least one entry is in the load queue:
    HANDLE m_hLoaderEvent;

    // A flag that tells the loader threads when it's time to terminate:
    volatile BOOL m_LoaderRunning;

    // A thread count variable that each loader thread increments at init time, and decrements at
    // termination time:
    volatile LONG m_ThreadCount;

    // Unloader thread handles:
    HANDLE m_hUnloaderThreads[MAX_UNLOADER_THREAD_COUNT];

    // A flag that tells the unloader threads that there's at least one entry in the unmap queue:
    HANDLE m_hUnloaderEvent;

    // Residency statistics that are computed each frame:
    ResidencyStats m_ResidencyStats;

    // A flag that indicates if all streaming should be paused:
    BOOL m_bPaused;

public:
    TitleResidencyManager( ID3D11Device* pd3dDevice, ID3D11DeviceContext* pd3dDeviceContext, UINT MaxViewsPerFrame, UINT MaxPhysicalTiles, ID3D11TilePool* pTilePool );
    ~TitleResidencyManager();

    VOID StartThreads();

    VOID Update( FLOAT fDeltaTime );
    const ResidencyStats& GetStats() const { return m_ResidencyStats; }

    VOID CreateResourceConstant( ResourceSetID RSID, XMFLOAT4* pConstant );

    UINT BeginView( ID3D11DeviceContext* pd3dDeviceContext, FLOAT FinalRenderWidth );
    VOID EndView( ID3D11DeviceContext* pd3dDeviceContext, UINT ViewID );
    VOID GetViewShaderResources( UINT ViewID, ID3D11ShaderResourceView** ppSRVUVGradientID, ID3D11ShaderResourceView** ppSRVExtendedUVSlice );

    ResourceSetID CreateResourceSet( const ID3D11TiledTexture2D** ppResources, ITileLoader** ppTileLoaders, UINT ResourceCount );

    VOID RegisterTileActivityHandler( ITileActivityHandler* pHandler );

    UINT GetTrackedTileCount() const { return (UINT)m_TrackedTileSortList.size(); }
    TrackedTileSortList::const_iterator GetTrackedTilesBegin() const { return m_TrackedTileSortList.begin(); }
    TrackedTileSortList::const_iterator GetTrackedTilesEnd() const { return m_TrackedTileSortList.end(); }

protected:
    static DWORD WINAPI LoaderThreadProc( VOID* pParam );
    VOID LoaderEntryPoint( const UINT ThreadIndex );

    static DWORD WINAPI UnloaderThreadProc( VOID* pParam );
    VOID UnloaderEntryPoint( const UINT ThreadIndex );

    BOOL IsTrackedTileExpired( TrackedTile* pTT ) const;

    static bool TrackedTileSortPredicate( const TrackedTile* pA, const TrackedTile* pB );
    VOID UpdateTileStates();
    VOID CollectViewSamples( SamplingView& View );
    VOID ProcessSample( const XMUBYTEN4& UVGradientIDSample, const XMUBYTEN4& ExtendedUVSliceSample, const UINT ViewPositionScore );
    TrackedTile* IncrementSampleCount( D3D11_TILED_VIRTUAL_ADDRESS VTileID, FLOAT TexU, FLOAT TexV, UINT SliceIndex, UINT MipLevel, ID3D11TiledTexture2D* pResource, ITileLoader* pTileLoader, const UINT ViewPositionScore );
    TrackedTile* AddVirtualTile( D3D11_TILED_VIRTUAL_ADDRESS VTileID, FLOAT TexU, FLOAT TexV, UINT SliceIndex, UINT MipLevel, ID3D11TiledTexture2D* pResource, ITileLoader* pTileLoader, const UINT ViewPositionScore );

    VOID QueueTileForLoadAndMap( TrackedTile* pTT, BOOL RecomputePriority );
    VOID QueueTileForUnmap( TrackedTile* pTT );

    UINT ComputePriority( TrackedTile* pTT ) const;

    VOID NotifyTileActivity( const TrackedTileID* pTileID, BOOL Loaded ) const;
};
